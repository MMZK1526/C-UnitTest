/* Boilerplate auto-generated by MMZK1526 */

#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "mmzktestbase.h"

typedef struct {
	char ch;
	int32_t xs[3];
	bool b;
} foo_t;

typedef struct {
	char ch;
	int32_t xs[3];
	bool b;
} bar_t;

typedef struct {
	char ch;
	bool b;
	int32_t xs[3];
} baz_t;

typedef enum {
	ZERO,
	ONE,
	TWO,
	THREE
} count_t;

static char *str_struct(const void *ptr) {
	char *str = (char *)malloc(128);
	foo_t foo = *(foo_t *)ptr;

	sprintf(str, "char: %c; bool: %s; xs: [%d, %d, %d]",
		foo.ch, MMZK_STR_BOOL(foo.b), foo.xs[0], foo.xs[1], foo.xs[2]);

	return str;
}

static char *str_count(const void *ptr) {
        char *str;

        switch (*(const count_t *)ptr) {
        case ZERO:
                str = malloc(5);
                strcpy(str, "ZERO");
                break;
        case ONE:
                str = malloc(4);
                strcpy(str, "ONE");
                break;
        case TWO:
                str = malloc(4);
                strcpy(str, "TWO");
                break;
        case THREE:
                str = malloc(6);
                strcpy(str, "THREE");
                break;
        default:
                str = malloc(15);
                strcpy(str, "!Invalid enum!");
                break;
        }

        return str;
}

static void string_test(void) {
	char *str1 = "abc", *str2 = "abc", *str3 = "ABC";
	mmzk_assert_pop_caption("Test string:\n");
	mmzk_assert_equal_string(str1, str2, "\tIdential Strings: ");
	mmzk_assert_equal_string(str1, str3, "\tUppercase & Lowercase: ");
	mmzk_assert_pop_caption("\n");
}

static void struct_test(void) {
	foo_t foo1 = 
		{ .ch = 'a', .xs[0] = 0, .xs[1] = 1, .xs[2] = 2, .b = false };
	foo_t foo2 = 
		{ .ch = 'a', .xs[0] = 0, .xs[1] = 1, .xs[2] = 2, .b = false };
	foo_t foo3 = 
		{ .ch = 'a', .xs[0] = 0, .xs[1] = 1, .xs[2] = 2, .b = true };
	bar_t bar = 
		{ .ch = 'a', .xs[0] = 0, .xs[1] = 1, .xs[2] = 2, .b = true };
	baz_t baz = 
		{ .ch = 'a', .xs[0] = 0, .xs[1] = 1, .xs[2] = 2, .b = true };
	mmzk_assert_pop_caption("Test same struct:\n");
	mmzk_assert_equal_struct(foo1, foo2, str_struct, "\tSame foo_t: ");
	mmzk_assert_equal_struct(foo1, foo3, str_struct, "\tDistinct foo_t: ");
	mmzk_assert_pop_caption("\n");

	mmzk_assert_pop_caption("Test different struct:\n");
	mmzk_assert_equal_struct(foo3, bar, str_struct, "\tSame Order: ");
	mmzk_assert_equal_struct(foo3, baz, str_struct, "\tDistinct Order: ");
	mmzk_assert_pop_caption("\n");
}

static void enum_test(void) {
	count_t a = ONE, b = ONE;
	uint8_t x = 1;
	mmzk_assert_pop_caption("Test enum:\n");
	mmzk_assert_equal_any(&a, &b, mmzk_eq_int8, str_count, "\tcount_t: ");
	mmzk_assert_pop_caption("\n");

	mmzk_assert_pop_caption("Test enum with int:\n");
	mmzk_assert_equal_any(&a, &x, mmzk_eq_int8, str_count, "\tcount_t: ");
	mmzk_assert_pop_caption("\n");
}

void compoundtest_summary(void) {
	mmzk_test_summary(string_test, "String Test (string_test):\n");
	mmzk_test_summary(struct_test, "Struct Test (struct_test):\n");
	mmzk_test_summary(enum_test, "Enum Test (enum_test):\n");
}

#ifdef TEST_MAIN

// Run with the option "-v" to go verbose (show successful tests).
int main(int argc, char **argv) {
	return mmzk_test_report(compoundtest_summary, argc, argv);
}

#endif /* TEST_MAIN */
